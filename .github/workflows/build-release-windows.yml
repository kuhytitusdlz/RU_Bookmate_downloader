name: Build & Release (Windows, no external actions)

on:
  push:
    branches: [ main ]     # авто-релиз на каждый пуш в main
  workflow_dispatch:       # и возможность запуска вручную

permissions:
  contents: write          # нужно для пуша тэгов и создания релизов

defaults:
  run:
    shell: pwsh

jobs:
  build_release_windows:
    runs-on: windows-latest
    steps:
      - name: Clone repository (no checkout action)
        env:
          REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = "Stop"
          git --version
          git config --global user.email "actions@github.com"
          git config --global user.name "github-actions[bot]"
          git clone "https://x-access-token:$env:GITHUB_TOKEN@github.com/$env:REPO" repo
          git config --global --add safe.directory "$(Resolve-Path ./repo)"
          Set-Location repo
          git fetch --tags --force

      - name: Auto bump tag (patch)
        id: bump
        run: |
          $prefix = 'v'
          $initial = 'v0.0.1'
          $tags = (git tag --list 'v*')
          if (-not $tags) {
            $newTag = $initial
          } else {
            # находим максимальный по семверу
            $latest = $tags | Sort-Object -Descending {[version]($_ -replace '^v','0.')} | Select-Object -First 1
            $ver = [version]($latest -replace '^v','')
            $newTag = "v{0}.{1}.{2}" -f $ver.Major, $ver.Minor, ($ver.Build + 1)
          }
          echo "NEW_TAG=$newTag" >> $env:GITHUB_ENV

          git tag -a $newTag -m "chore: release $newTag"
          git push origin $newTag
          Write-Host "Bumped and pushed tag $newTag"

      - name: Ensure Python
        run: |
          if (-not (Get-Command python -ErrorAction SilentlyContinue)) {
            choco install python -y
            refreshenv
          }
          python --version
          python -m pip install --upgrade pip
          if (Test-Path "requirements.txt") { python -m pip install -r requirements.txt }
          python -m pip install pyinstaller

      - name: Build EXE with PyInstaller
        run: |
          # поменяйте имя входного скрипта при необходимости
          pyinstaller --noconfirm --onefile --name RUBookmatedownloader RUBookmatedownloader.py
          if (!(Test-Path "dist/RUBookmatedownloader.exe")) {
            throw "EXE not found at dist/RUBookmatedownloader.exe"
          }

      - name: Download FFmpeg (BtbN)
        run: |
          $ffUrl = "https://github.com/BtbN/FFmpeg-Builds/releases/latest/download/ffmpeg-master-latest-win64-gpl-shared.zip"
          Invoke-WebRequest -Uri $ffUrl -OutFile ffmpeg.zip
          Expand-Archive ffmpeg.zip -DestinationPath ffmpeg -Force

      - name: Prepare ZIP bundle
        run: |
          $bundleRoot = "bundle"
          $bundleName = "RUBookmateDownloader-win64-$env:NEW_TAG"
          $bundleDir  = Join-Path $bundleRoot $bundleName
          New-Item -ItemType Directory -Force -Path "$bundleDir" | Out-Null
          New-Item -ItemType Directory -Force -Path "$bundleDir\ffmpeg\bin" | Out-Null

          Copy-Item "dist\RUBookmatedownloader.exe" "$bundleDir\RUBookmatedownloader.exe"
          # копируем ключевые бинарники ffmpeg
          $ffBin = Get-ChildItem -Recurse ".\ffmpeg" | Where-Object { $_.Name -in @("ffmpeg.exe","ffplay.exe","ffprobe.exe") }
          foreach ($f in $ffBin) { Copy-Item $f.FullName "$bundleDir\ffmpeg\bin\" -Force }

          if (Test-Path "README.md") { Copy-Item "README.md" "$bundleDir\" }

          New-Item -ItemType Directory -Force -Path $bundleRoot | Out-Null
          $zipPath = "$bundleRoot\$bundleName.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path "$bundleDir\*" -DestinationPath $zipPath
          Write-Host "ZIP ready: $zipPath"
          echo "ZIP_PATH=$zipPath" >> $env:GITHUB_ENV

      - name: Create GitHub Release & Upload asset (gh CLI)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # gh возьмёт токен из переменной
        run: |
          gh --version
          gh release create "$env:NEW_TAG" "$env:ZIP_PATH" --title "Release $env:NEW_TAG" --generate-notes
          Write-Host "Release $env:NEW_TAG created with asset $env:ZIP_PATH"
